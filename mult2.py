# Решето Эратосфена с линейным временем работы
# Этот алгоритм обнаруживает для каждого числа i в отрезке [2...n] его минимальный простой делитель lp[i].

# Также поддерживается список всех простых чисел — массив pr[], поначалу пустой. В ходе работы алгоритма этот массив будет постепенно заполняться.

# Изначально все величины lp[i] заполним нулями.

# Дальше следует перебрать текущее число i от 2 до n. Здесь может быть два случая:

#   lp[i] = 0: это означает, что число i — простое, так как для него так и не обнаружилось других делителей.
# Следовательно, надо присвоить lp[i] = i и добавить i в конец списка pr[].

#  lp[i] ≠ 0: это означает, что текущее число i — составное, и его минимальным простым делителем является lp[i].
# В обоих случаях дальше начинается процесс расстановки значений в массиве lp[i]: следует брать числа, кратные i,
# и обновлять у них значение lp[]. Однако основная цель — научиться делать это таким образом, чтобы в итоге у каждого числа значение lp[]
# было бы установлено не более одного раза.

# Утверждается, что для этого можно поступить таким образом. Рассматриваются числа вида x = p * i, 
# где p последовательно равно всем простым числам не превосходящим lp[i] (как раз для этого понадобилось хранить список всех простых чисел).

# У всех чисел такого вида проставим новое значение lp[x] — оно должно быть равно p.


#  Вход: натуральное число n
# Пусть pr - целочисленный массив, поначалу пустой;
#       lp - целочисленный массив, индексируемый от 2 до n, заполненный нулями

#  для i := 2, 3, 4, ..., до n: 
#    если lp[i] = 0:
#        lp[i] := i
#        pr[] += {i}
#    для p из pr пока p ≤ lp[i] и p*i ≤ n:
#        lp[p*i] := p

# Выход: все числа в массиве pr.

import time
start = time.clock()
n = 100000000
pr = []
lp = [0]*(n+1)
i = 2
while i < (n+1):
	if lp[i] == 0:
		lp[i] = i
		pr.append(i)
	j = 0
	while (j < len(pr) and pr[j] <= lp[i] and i*pr[j] <= n):
		lp[pr[j]*i] = pr[j]
		j += 1
	i += 1

res = time.clock() - start
print(len(pr))
print(res)

# 1M
# (interesting) E:\homework\interesting>python mult2.py
# 2.1944317522639634
# 10M
# (interesting) E:\homework\interesting>python mult2.py
# 22.499732951048962
# 100M
# 247.23222256569795